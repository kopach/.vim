filetype off

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

" Define bundles via Github repos
				"Plugin manager
Bundle 'VundleVim/Vundle.vim'
				"File tree
Bundle 'scrooloose/nerdtree'
				" Open non text files from nerdtree with an appropriate application.
Bundle 'aufgang001/vim-nerdtree_plugin_open'
				"A plugin for NERDTree showing git status flags
Bundle 'Xuyuanp/nerdtree-git-plugin'
				"Status line
Bundle 'bling/vim-airline'
				"Useful commenting
Bundle 'tomtom/tcomment_vim'
				"Git features
Bundle 'tpope/vim-fugitive'
				"Syntax checking plugin / also style checking
Bundle 'scrooloose/syntastic'
				" Shows a git diff in the 'gutter' (sign column)
Bundle 'airblade/vim-gitgutter'
				" Provides useful mappings which allow to move between Vim panes and tmux splits seamlessly
Bundle 'christoomey/vim-tmux-navigator'
				" Base 16 color themes
Bundle 'chriskempson/base16-vim'
				" tmux integration for vim
Bundle 'benmills/vimux'
				" JavaScript Syntax highlighting with ES6 support
Bundle 'othree/yajs.vim'

Bundle 'kien/ctrlp.vim'
Bundle 'repeat.vim'
Bundle 'visualrepeat'
				" Adds ability to surrond anything by quotes or tags
Bundle 'tpope/vim-surround'
Bundle 'rking/ag.vim'
				" Text formatter
Bundle 'Chiel92/vim-autoformat'
Bundle 'terryma/vim-multiple-cursors'

				" Easy navigate through document
Bundle 'easymotion/vim-easymotion'

				" Markdown previews from VIm!
Bundle 'shime/vim-livedown'

				" Allows convert text into different cases: camelCase, snake_case, etc
Bundle 'tpope/vim-abolish'

				" Allows to use .editorconfig
Bundle 'editorconfig/editorconfig-vim'

				" Snippents list for snipmate or ultisnips
Plugin 'honza/vim-snippets'
				" Snippents engine, works fine with youcompleteme
Plugin 'SirVer/ultisnips'

				" JSDoc generator
Plugin 'heavenshell/vim-jsdoc'
				" Browse the tags of the current file and get an overview of its structure
" Plugin 'majutsushi/tagbar'
				" JavaScript parser (needed for tagbar)
" Plugin 'ternjs/tern_for_vim'
				" A code-completion engine for Vim
Plugin 'valloric/youcompleteme'
				" Zoom in/out of windows/splits
Plugin 'regedarek/ZoomWin'

				" Vue.js syntax
Plugin 'posva/vim-vue'

				" Search and replace a pattern across multiple files interactively
Plugin 'yegappan/greplace'

				" A parser for a condensed HTML format, simmilar to zen codding
				" (Ctrl+E in insert mode)
Plugin 'rstacruz/sparkup'

" VimVue config
" autocmd BufRead,BufNewFile *.vue setlocal filetype=vue.html.javascript.css

" EasyMotion settings
map <Leader> <Plug>(easymotion-prefix)

" ZoomWin config
nmap <F11> :ZoomWin<CR>

" Youcompleteme settings
" suggests completion by Alt+Space
let g:ycm_key_invoke_completion = '<A-Space>'
" close Preview window after exit insert mode
let g:ycm_autoclose_preview_window_after_insertion = 1

" Tagbar config
nmap <F12> :TagbarToggle<CR>
" Tagbar css+scss config
let g:tagbar_type_css = {
\ 'ctagstype' : 'css',
    \ 'kinds'     : [
        \ 'c:classes',
        \ 's:selectors',
        \ 'i:identities'
    \ ]
\ }
let g:tagbar_type_scss = g:tagbar_type_css

" JSDoc settings
map <Leader>js :JsDoc<CR><CR>
" Allow prompt for interactive input.
let g:jsdoc_allow_input_prompt = 1
let g:jsdoc_input_description = 1
" let g:jsdoc_additional_descriptions = 1
" let g:jsdoc_access_descriptions = 1
let g:jsdoc_underscore_private = 1
let g:jsdoc_enable_es6 = 1

"Markdown settings
autocmd BufNewFile,BufReadPost *.ngdoc set filetype=markdown
" let vim_markdown_preview_hotkey='<C-m>'
nmap gm :LivedownToggle<CR>
"
" should markdown preview get shown automatically upon opening markdown buffer
let g:livedown_autorun = 0

" should the browser window pop-up upon previewing
let g:livedown_open = 1

" the port on which Livedown server will run
let g:livedown_port = 1337

" the system command to launch a browser (ex. on linux)
" let g:livedown_browser = firefox

" the system command to launch a browser (ex. on OSX)
let g:livedown_browser = "chromium"


"CtrlP settings
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'

"For matching tags and more with % key
Bundle 'matchit.zip'

"For tags highlighting
Bundle 'Valloric/MatchTagAlways'

call vundle#end()            " required
filetype plugin indent on    " required

"SnipMate settings
" Enable snippets from custom-snippets/UltiSnips/
autocmd FileType javascript UltiSnipsAddFiletypes es6-jasmine
" Tell UltiSnips whe to find custom snippets
set runtimepath+=~/.vim/custom-snippets

" Toggle NERDTree
map <F10> :NERDTreeToggle<CR>
" Current file in NERDTree
map <F9> :NERDTreeFind<CR>

" Syntastic
let g:syntastic_javascript_checkers = ['eslint'] "['jshint', 'jscs']
let g:syntastic_json_checkers = ['jsonlint']
let g:syntastic_less_checkers = ['lessc']
let g:syntastic_css_checkers = ['csslint']
"Recommended settings https://github.com/scrooloose/syntastic/blob/master/doc/syntastic.txt#L122
" let g:syntastic_always_populate_loc_list = 1
" let g:syntastic_auto_loc_list = 1 "Auto open list of errors in separate split
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

" Vimux settings
"nmap <leader>nrs :call VimuxRunCommand('npm run serve')<cr>
"nmap <leader>nrsm :call VimuxRunCommand('npm run serve:mock')<cr>
"nmap <leader>nt :call VimuxRunCommand('npm run tdd')<cr>
"nmap <leader>nrb :call VimuxRunCommand('npm run build')<cr>
 
 " Prompt for a command to run
 "map <Leader>vp :VimuxPromptCommand<CR>

 " Run last command executed by VimuxRunCommand
"nmap <Leader>vl :VimuxRunLastCommand<CR>

" Autoformat
let g:formatterpath = ['jscs']
noremap <F5> :Autoformat<CR>

" Multiple cursors
let g:multi_cursor_use_default_mapping=0 " Disable default keys mapping
" New mapping
let g:multi_cursor_start_key='<C-n>'
let g:multi_cursor_next_key='<C-n>'
let g:multi_cursor_prev_key='<C-p>'
let g:multi_cursor_skip_key='<C-x>'
let g:multi_cursor_quit_key='<C-c>'

" The Silver Searcher (Ag)
if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor

  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
endif

" Search word under cursor
nnoremap K :Ag! "\b<C-R><C-W>\b"<CR>:cw<CR>

" Open search dialog
map <F3> :Ag!

" Configure NerdtreePluginOpen
" let g:nerdtree_plugin_open_cmd = 'gnome-open'
let g:nerdtree_plugin_open_cmd = 'open'

"Move the tab to the left
" map <C-H> :execute "tabmove" tabpagenr() - 2 <CR>
"Move the tab to the right
" map <C-L> :execute "tabmove" tabpagenr() <CR>

autocmd BufRead,BufNewFile *.less set filetype=less " it is need for Syntastic ( try :SyntasticInfo )
autocmd BufRead,BufNewFile *.less set syntax=css "  enable css syntax in *.less files
autocmd BufRead,BufNewFile *.scss set filetype=scss " it is need for Syntastic ( try :SyntasticInfo )

" Rename tabs to show tab number
set tabline=%!MyTabLine()
function MyTabLine()
  let s = '' " complete tabline goes here
  " loop through each tab page
  for t in range(tabpagenr('$'))
    " select the highlighting for the buffer names
    if t + 1 == tabpagenr()
      let s .= '%#TabLineSel#'
    else
      let s .= '%#TabLine#'
    endif
    " empty space
    let s .= ' '
    " set the tab page number (for mouse clicks)
    let s .= '%' . (t + 1) . 'T'
    " set page number string
    let s .= t + 1 . ' '
    " get buffer names and statuses
    let n = ''  "temp string for buffer names while we loop and check buftype
    let m = 0 " &modified counter
    let bc = len(tabpagebuflist(t + 1))  "counter to avoid last ' '
    " loop through each buffer in a tab
    for b in tabpagebuflist(t + 1)
      " buffer types: quickfix gets a [Q], help gets [H]{base fname}
      " others get 1dir/2dir/3dir/fname shortened to 1/2/3/fname
      if getbufvar( b, "&buftype" ) == 'help'
        let n .= '[H]' . fnamemodify( bufname(b), ':t:s/.txt$//' )
      elseif getbufvar( b, "&buftype" ) == 'quickfix'
        let n .= '[Q]'
      else
        let n .= pathshorten(bufname(b))
        "let n .= bufname(b)
      endif
      " check and ++ tab's &modified count
      if getbufvar( b, "&modified" )
        let m += 1
      endif
      " no final ' ' added...formatting looks better done later
      if bc > 1
        let n .= ' '
      endif
      let bc -= 1
    endfor
    " add modified label [n+] where n pages in tab are modified
    if m > 0
      "let s .= '[' . m . '+]'
      let s.= '+ '
    endif
    " add buffer names
    if n == ''
      let s .= '[No Name]'
    else
      let s .= n
    endif
    " switch to no underlining and add final space to buffer list
    "let s .= '%#TabLineSel#' . ' '
    let s .= ' '
  endfor
  " after the last tab fill with TabLineFill and reset tab page nr
  let s .= '%#TabLineFill#%T'
  " right-align the label to close the current tab page
  if tabpagenr('$') > 1
    let s .= '%=%#TabLine#%999XX'
  endif
  return s
endfunction


" TODO: investigate this
" neocomplete.vim
" vim-autoformat
" vim-easy-align
" vim-json


" Highlight words under the cursor like many IDEs
" autocmd CursorMoved * silent! exe printf('match IncSearch /\<%s\>/', expand('<cword>'))

